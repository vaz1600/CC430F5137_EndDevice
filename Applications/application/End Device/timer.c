// *************************************************************************************************
//
//      Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
//
//
//        Redistribution and use in source and binary forms, with or without
//        modification, are permitted provided that the following conditions
//        are met:
//
//          Redistributions of source code must retain the above copyright
//          notice, this list of conditions and the following disclaimer.
//
//          Redistributions in binary form must reproduce the above copyright
//          notice, this list of conditions and the following disclaimer in the
//          documentation and/or other materials provided with the
//          distribution.
//
//          Neither the name of Texas Instruments Incorporated nor the names of
//          its contributors may be used to endorse or promote products derived
//          from this software without specific prior written permission.
//
//        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
//        "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
//        LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
//        A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
//        OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
//        SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//        LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
//        DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
//        THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
//        (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
//        OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// *************************************************************************************************
// Timer service routines.
// *************************************************************************************************

// *************************************************************************************************
// Include section

// system
#include "bsp.h"

// driver
#include "timer.h"


// *************************************************************************************************
// Prototypes section
void Timer1_Init(void);
void Timer1_Stop(void);
void Timer1_A1_Start(void);
void Timer1_A1_Stop(void);
void Timer1_A3_Start(uint16_t ticks);
void Timer1_A3_Stop(void);
void Timer1_A4_Delay(uint16_t ticks);

void (*fptr_Timer1_A3_function)(void);

// *************************************************************************************************
// Defines section

// *************************************************************************************************
// Global Variable section
struct timer sTimer;
uint32_t clock_tick;
uint32_t exit_sleep_tick;

// *************************************************************************************************


// *************************************************************************************************
// @fn          Timer1_Init
// @brief       Set Timer1 to a period of 1 or 2 sec. IRQ TACCR0 is asserted when timer overflows.
// @param       none
// @return      none
// *************************************************************************************************
void Timer1_Init(void)
{
    // Set interrupt frequency to 1Hz
    TA1CCR0 = 32768 - 1;

    // Enable timer interrupt
    TA1CCTL0 |= CCIE;

    // Clear and start timer now
    // Continuous mode: Count to 0xFFFF and restart from 0 again - 1sec timing will be generated by
    // ISR
    TA1CTL |= TASSEL0 + MC1 + TACLR;
}

// *************************************************************************************************
// @fn          Timer1_Start
// @brief       Start Timer1.
// @param       none
// @return      none
// *************************************************************************************************
void Timer1_Start(void)
{
    // Start Timer1 in continuous mode
    TA1CTL |= MC_2;
}

// *************************************************************************************************
// @fn          Timer1_Stop
// @brief       Stop and reset Timer1.
// @param       none
// @return      none
// *************************************************************************************************
void Timer1_Stop(void)
{
    // Stop Timer1
    TA1CTL &= ~MC_2;

    // Set Timer1 count register to 0x0000
    TA1R = 0;
}

// *************************************************************************************************
// @fn          Timer1_A3_Start
// @brief       Trigger IRQ every "ticks" microseconds
// @param       ticks (1 tick = 1/32768 sec)
// @return      none
// *************************************************************************************************
void Timer1_A3_Start(uint16_t ticks)
{
    uint16_t value = 0;

    // Store timer ticks in global variable
    sTimer.timer1_A3_ticks = ticks;

    // Delay based on current counter value
    // To make sure this value is correctly read
    while (value != TA1R)
        value = TA1R;
    value += ticks;

    // Update CCR
    TA1CCR1 = value;

    // Reset IRQ flag
    TA1CCTL1 &= ~CCIFG;

    // Enable timer interrupt
    TA1CCTL1 |= CCIE;
}

// *************************************************************************************************
// @fn          Timer1_A3_Stop
// @brief       Stop Timer1_A3.
// @param       none
// @return      none
// *************************************************************************************************
void Timer1_A3_Stop(void)
{
    // Clear timer interrupt
    TA1CCTL1 &= ~CCIE;
}

// *************************************************************************************************
// @fn          Timer1_A4_Delay
// @brief       Wait for some microseconds
// @param       ticks (1 tick = 1/32768 sec)
// @return      none
// *************************************************************************************************
void Timer1_A4_Delay(uint16_t ticks)
{
    uint16_t value = 0;

    // Exit immediately if Timer1 not running - otherwise we'll get stuck here
    if ((TA1CTL & (BIT4 | BIT5)) == 0)
        return;

    // Disable timer interrupt
    TA1CCTL2 &= ~CCIE;

    // Clear delay_over flag
    sTimer.delay_over = 0;

    // Add delay to current timer value
    // To make sure this value is correctly read
    while (value != TA1R)
        value = TA1R;
    value += ticks;

    // Update CCR
    TA1CCR2 = value;

    // Reset IRQ flag
    TA1CCTL2 &= ~CCIFG;

    // Enable timer interrupt
    TA1CCTL2 |= CCIE;

    // Wait for timer IRQ
    while (1)
    {
        // Delay in LPM
        //to_lpm();               // will also set GIE again
        _BIS_SR(LPM3_bits + GIE);
        __no_operation();

#ifdef USE_WATCHDOG
        // Service watchdog
        WDTCTL = WDTPW + WDTIS__512K + WDTSSEL__ACLK + WDTCNTCL;
#endif

        // Check stop condition
        // disable interrupt to prevent flag's change caused by interrupt methods
        __disable_interrupt();
        if (sTimer.delay_over)
            break;
    }
    __enable_interrupt();
}

// *************************************************************************************************
// @fn          Timer1_A0_ISR
// @brief       IRQ handler for Timer1_A0 IRQ
//                              Timer1_A0       1/1sec clock tick                       (serviced by
// function Timer1_A0_ISR)
//                              Timer1_A1
//                                                               (serviced by function
// Timer1_A1_5_ISR)
//                              Timer1_A2       1/100 sec Stopwatch                     (serviced by
// function Timer1_A1_5_ISR)
//                              Timer1_A3       Configurable periodic IRQ       (serviced by
// function Timer1_A1_5_ISR)
//                              Timer1_A4       One-time delay                          (serviced by
// function Timer1_A1_5_ISR)
// @param       none
// @return      none
// *************************************************************************************************
#pragma vector = TIMER1_A0_VECTOR
__interrupt void Timer1_A0_ISR(void)
{
    // Disable IE
    TA1CCTL0 &= ~CCIE;
    // Reset IRQ flag
    TA1CCTL0 &= ~CCIFG;
    // Add 1 sec to TACCR0 register (IRQ will be asserted at 0x7FFF and 0xFFFF = 1 sec intervals)
    TA1CCR0 += 32768;
    // Enable IE
    TA1CCTL0 |= CCIE;

    // Add 1 second to global time
    //clock_tick();
    if(fptr_one_sec_function)
        fptr_one_sec_function();

    LPM3_EXIT;
}

// *************************************************************************************************
// @fn          Timer1_A1_5_ISR
// @brief       IRQ handler for timer IRQ.
//                              Timer1_A0       1/1sec clock tick (serviced by function
// Timer1_A0_ISR)
//                              Timer1_A1       BlueRobin timer
//                              Timer1_A2       1/100 sec Stopwatch
//                              Timer1_A3       Configurable periodic IRQ (used by button_repeat and
// buzzer)
//                              Timer1_A4       One-time delay
// @param       none
// @return      none
// *************************************************************************************************
#pragma vector = TIMER1_A1_VECTOR
__interrupt void Timer1_A1_5_ISR(void)
{
    uint16_t value = 0;

    switch (TA1IV)
    {

        // Timer1_A1    Configurable periodic IRQ (used by button_repeat and buzzer)
        case 0x02:             // Disable IE
            TA1CCTL1 &= ~CCIE;
            // Reset IRQ flag
            TA1CCTL1 &= ~CCIFG;
            // Store new value in CCR
            // To make sure this value is correctly read
            while (value != TA1R)
                value = TA1R;
            value += sTimer.timer1_A3_ticks;
            // Load CCR register with next capture point
            TA1CCR1 = value;
            // Enable timer interrupt
            TA1CCTL1 |= CCIE;
            // Call function handler
            fptr_Timer1_A3_function();
            break;

        // Timer1_A2    One-time delay
        case 0x04:             // Disable IE
            TA1CCTL2 &= ~CCIE;
            // Reset IRQ flag
            TA1CCTL2 &= ~CCIFG;
            // Set delay over flag
            sTimer.delay_over = 1;
            break;
    }

    // Exit from LPM3 on RETI
    //_BIC_SR_IRQ(LPM3_bits);
    LPM3_EXIT;
}

